{"version":3,"sources":["index.js"],"names":[],"mappings":";;;AAGA,IAAI,WAAW,QAAQ,gBAAR,CAAX;;;;;;;AAOJ,OAAO,OAAP,GAAiB,kBAAjB;;;;;;;;;AASA,SAAS,kBAAT,CAA4B,MAA5B,EAAoC,UAApC,EAAgD,QAAhD,EAA0D;AACxD,MAAI,OAAO,MAAP,CADoD;AAExD,SAAO,iBAAiB,MAAjB,EAAyB,UAAzB,EAAqC,MAArC,CAA4C,UAAS,MAAT,EAAiB,GAAjB,EAAsB;AACvE,WAAO,OAAO,OAAP,CAAe,IAAI,kBAAJ,GAAyB,GAAzB,GAA+B,IAAI,OAAJ,CAAY,IAAZ,GAAmB,GAAlD,EAAuD,iBAAiB,IAAI,OAAJ,CAAY,IAAZ,EAAkB,IAAI,kBAAJ,EAAwB,QAA3D,EAAqE,IAArE,EAA2E,UAA3E,CAAtE,CAAP,CADuE;GAAtB,EAEhD,MAFI,CAAP,CAFwD;CAA1D;;;;;;;;;;AAeA,SAAS,gBAAT,CAA0B,IAA1B,EAAgC,UAAhC,EAA4C;AAC1C,MAAI,cAAc,EAAd,CADsC;;AAG1C,MAAI,OAAO,OAAO,UAAP,KAAsB,QAAtB,GAAiC,IAAI,MAAJ,CAAW,SAAS,UAAT,GAAsB,MAAtB,CAA5C,GAA4E,UAA5E,CAH+B;AAI1C,KAAG;AACD,QAAI,cAAc,KAAK,IAAL,CAAU,IAAV,CAAd,CADH;AAED,QAAI,CAAC,WAAD,EAAc;AAChB,aAAO,WAAP,CADgB;KAAlB;AAGA,QAAI,YAAY,CAAZ,MAAmB,SAAnB,EAA8B;AAChC,YAAM,IAAI,KAAJ,CAAU,+EAA+E,UAA/E,CAAhB,CADgC;KAAlC;AAGA,QAAI,KAAK,YAAY,CAAZ,CAAL,CARH;AASD,QAAI,aAAa,YAAY,KAAZ,CAThB;AAUD,QAAI,UAAU,SAAS,GAAT,EAAc,GAAd,EAAmB,KAAK,SAAL,CAAe,UAAf,CAAnB,CAAV,CAVH;;AAYD,QAAI,CAAC,OAAD,EAAU;AACZ,YAAM,IAAI,WAAJ,CAAgB,KAAK,wCAAL,GAAgD,IAAhD,GAAuD,GAAvD,CAAtB,CADY;KAAd;;AAIA,gBAAY,IAAZ,CAAiB,EAAC,SAAS,OAAT,EAAkB,oBAAoB,EAApB,EAApC,EAhBC;AAiBD,WAAO,QAAQ,IAAR,CAjBN;GAAH,QAmBO,KAAK,IAAL,CAAU,IAAV,CAnBP,EAJ0C;;AAyB1C,SAAO,WAAP,CAzB0C;CAA5C;;;;;;;;;;AAoCA,SAAS,gBAAT,CAA2B,MAA3B,EAAmC,kBAAnC,EAAuD,QAAvD,EAAiE,IAAjE,EAAuE,UAAvE,EAAmF;;AAEjF,SAAO,SAAS,mBAAmB,MAAnB,EAA2B,UAA3B,EAAuC,QAAvC,CAAT,EAA2D,kBAA3D,EAA+E,IAA/E,CAAP,CAFiF;CAAnF","file":"index-compiled.js","sourcesContent":["/*\n * Module dependencies\n */\nvar balanced = require(\"balanced-match\")\n\n/**\n * Expose `reduceFunctionCall`\n *\n * @type {Function}\n */\nmodule.exports = reduceFunctionCall\n\n/**\n * Walkthrough all expressions, evaluate them and insert them into the declaration\n *\n * @param {Array} expressions\n * @param {Object} declaration\n */\n\nfunction reduceFunctionCall(string, functionRE, callback) {\n  var call = string\n  return getFunctionCalls(string, functionRE).reduce(function(string, obj) {\n    return string.replace(obj.functionIdentifier + \"(\" + obj.matches.body + \")\", evalFunctionCall(obj.matches.body, obj.functionIdentifier, callback, call, functionRE))\n  }, string)\n}\n\n/**\n * Parses expressions in a value\n *\n * @param {String} value\n * @returns {Array}\n * @api private\n */\n\nfunction getFunctionCalls(call, functionRE) {\n  var expressions = []\n\n  var fnRE = typeof functionRE === \"string\" ? new RegExp(\"\\\\b(\" + functionRE + \")\\\\(\") : functionRE\n  do {\n    var searchMatch = fnRE.exec(call)\n    if (!searchMatch) {\n      return expressions\n    }\n    if (searchMatch[1] === undefined) {\n      throw new Error(\"Missing the first couple of parenthesis to get the function identifier in \" + functionRE)\n    }\n    var fn = searchMatch[1]\n    var startIndex = searchMatch.index\n    var matches = balanced(\"(\", \")\", call.substring(startIndex))\n\n    if (!matches) {\n      throw new SyntaxError(fn + \"(): missing closing ')' in the value '\" + call + \"'\")\n    }\n\n    expressions.push({matches: matches, functionIdentifier: fn})\n    call = matches.post\n  }\n  while (fnRE.test(call))\n\n  return expressions\n}\n\n/**\n * Evaluates an expression\n *\n * @param {String} expression\n * @returns {String}\n * @api private\n */\n\nfunction evalFunctionCall (string, functionIdentifier, callback, call, functionRE) {\n  // allow recursivity\n  return callback(reduceFunctionCall(string, functionRE, callback), functionIdentifier, call)\n}\n"]}