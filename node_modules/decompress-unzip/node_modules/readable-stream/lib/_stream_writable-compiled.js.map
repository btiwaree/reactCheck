{"version":3,"sources":["_stream_writable.js"],"names":[],"mappings":"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","file":"_stream_writable-compiled.js","sourcesContent":["// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // create the two objects needed to store the corked requests\n  // they are not a linked list, as no new elements are inserted in there\n  this.corkedRequestsFree = new CorkedRequest(this);\n  this.corkedRequestsFree.next = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    state.corkedRequestsFree = holder.next;\n    holder.next = null;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}"]}