{"version":3,"sources":["modArgs.js"],"names":[],"mappings":"AAAA,IAAI,aAAa,QAAQ,wBAAR,CAAb;IACA,cAAc,QAAQ,yBAAR,CAAd;IACA,iBAAiB,QAAQ,4BAAR,CAAjB;IACA,YAAY,QAAQ,aAAR,CAAZ;;;AAGJ,IAAI,kBAAkB,qBAAlB;;;AAGJ,IAAI,YAAY,KAAK,GAAL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiChB,IAAI,UAAU,UAAU,UAAS,IAAT,EAAe,UAAf,EAA2B;AACjD,eAAa,YAAY,UAAZ,CAAb,CADiD;AAEjD,MAAI,OAAO,IAAP,IAAe,UAAf,IAA6B,CAAC,WAAW,UAAX,EAAuB,cAAvB,CAAD,EAAyC;AACxE,UAAM,IAAI,SAAJ,CAAc,eAAd,CAAN,CADwE;GAA1E;AAGA,MAAI,SAAS,WAAW,MAAX,CALoC;AAMjD,SAAO,UAAU,UAAS,IAAT,EAAe;AAC9B,QAAI,QAAQ,UAAU,KAAK,MAAL,EAAa,MAAvB,CAAR,CAD0B;AAE9B,WAAO,OAAP,EAAgB;AACd,WAAK,KAAL,IAAc,WAAW,KAAX,EAAkB,KAAK,KAAL,CAAlB,CAAd,CADc;KAAhB;AAGA,WAAO,KAAK,KAAL,CAAW,IAAX,EAAiB,IAAjB,CAAP,CAL8B;GAAf,CAAjB,CANiD;CAA3B,CAApB;;AAeJ,OAAO,OAAP,GAAiB,OAAjB","file":"modArgs-compiled.js","sourcesContent":["var arrayEvery = require('../internal/arrayEvery'),\n    baseFlatten = require('../internal/baseFlatten'),\n    baseIsFunction = require('../internal/baseIsFunction'),\n    restParam = require('./restParam');\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Creates a function that runs each argument through a corresponding\n * transform function.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to wrap.\n * @param {...(Function|Function[])} [transforms] The functions to transform\n * arguments, specified as individual functions or arrays of functions.\n * @returns {Function} Returns the new function.\n * @example\n *\n * function doubled(n) {\n *   return n * 2;\n * }\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * var modded = _.modArgs(function(x, y) {\n *   return [x, y];\n * }, square, doubled);\n *\n * modded(1, 2);\n * // => [1, 4]\n *\n * modded(5, 10);\n * // => [25, 20]\n */\nvar modArgs = restParam(function(func, transforms) {\n  transforms = baseFlatten(transforms);\n  if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var length = transforms.length;\n  return restParam(function(args) {\n    var index = nativeMin(args.length, length);\n    while (index--) {\n      args[index] = transforms[index](args[index]);\n    }\n    return func.apply(this, args);\n  });\n});\n\nmodule.exports = modArgs;\n"]}