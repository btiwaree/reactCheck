{"version":3,"sources":["binaryIndexBy.js"],"names":[],"mappings":";AACA,IAAI,cAAc,KAAK,KAAL;IACd,YAAY,KAAK,GAAL;;;AAGhB,IAAI,mBAAmB,UAAnB;IACA,kBAAkB,mBAAmB,CAAnB;;;;;;;;;;;;;;;AAetB,SAAS,aAAT,CAAuB,KAAvB,EAA8B,KAA9B,EAAqC,QAArC,EAA+C,UAA/C,EAA2D;AACzD,UAAQ,SAAS,KAAT,CAAR,CADyD;;AAGzD,MAAI,MAAM,CAAN;MACA,OAAO,QAAQ,MAAM,MAAN,GAAe,CAAvB;MACP,WAAW,UAAU,KAAV;MACX,YAAY,UAAU,IAAV;MACZ,aAAa,UAAU,SAAV,CAPwC;;AASzD,SAAO,MAAM,IAAN,EAAY;AACjB,QAAI,MAAM,YAAY,CAAC,MAAM,IAAN,CAAD,GAAe,CAAf,CAAlB;QACA,WAAW,SAAS,MAAM,GAAN,CAAT,CAAX;QACA,QAAQ,aAAa,SAAb;QACR,cAAc,aAAa,QAAb,CAJD;;AAMjB,QAAI,QAAJ,EAAc;AACZ,UAAI,SAAS,eAAe,UAAf,CADD;KAAd,MAEO,IAAI,SAAJ,EAAe;AACpB,eAAS,eAAe,KAAf,KAAyB,cAAc,YAAY,IAAZ,CAAvC,CADW;KAAf,MAEA,IAAI,UAAJ,EAAgB;AACrB,eAAS,gBAAgB,cAAc,KAAd,CAAhB,CADY;KAAhB,MAEA,IAAI,YAAY,IAAZ,EAAkB;AAC3B,eAAS,KAAT,CAD2B;KAAtB,MAEA;AACL,eAAS,aAAc,YAAY,KAAZ,GAAsB,WAAW,KAAX,CADxC;KAFA;AAKP,QAAI,MAAJ,EAAY;AACV,YAAM,MAAM,CAAN,CADI;KAAZ,MAEO;AACL,aAAO,GAAP,CADK;KAFP;GAjBF;AAuBA,SAAO,UAAU,IAAV,EAAgB,eAAhB,CAAP,CAhCyD;CAA3D;;AAmCA,OAAO,OAAP,GAAiB,aAAjB","file":"binaryIndexBy-compiled.js","sourcesContent":["/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeMin = Math.min;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/**\n * This function is like `binaryIndex` except that it invokes `iteratee` for\n * `value` and each element of `array` to compute their sort ranking. The\n * iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction binaryIndexBy(array, value, iteratee, retHighest) {\n  value = iteratee(value);\n\n  var low = 0,\n      high = array ? array.length : 0,\n      valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsUndef = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        isDef = computed !== undefined,\n        isReflexive = computed === computed;\n\n    if (valIsNaN) {\n      var setLow = isReflexive || retHighest;\n    } else if (valIsNull) {\n      setLow = isReflexive && isDef && (retHighest || computed != null);\n    } else if (valIsUndef) {\n      setLow = isReflexive && (retHighest || isDef);\n    } else if (computed == null) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? (computed <= value) : (computed < value);\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\nmodule.exports = binaryIndexBy;\n"]}