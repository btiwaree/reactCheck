{"version":3,"sources":["lazyValue.js"],"names":[],"mappings":"AAAA,IAAI,mBAAmB,QAAQ,oBAAR,CAAnB;IACA,UAAU,QAAQ,WAAR,CAAV;IACA,UAAU,QAAQ,iBAAR,CAAV;;;AAGJ,IAAI,mBAAmB,GAAnB;;;AAGJ,IAAI,mBAAmB,CAAnB;IACA,gBAAgB,CAAhB;;;AAGJ,IAAI,YAAY,KAAK,GAAL;;;;;;;;;;AAUhB,SAAS,SAAT,GAAqB;AACnB,MAAI,QAAQ,KAAK,WAAL,CAAiB,KAAjB,EAAR;MACA,MAAM,KAAK,OAAL;MACN,QAAQ,QAAQ,KAAR,CAAR;MACA,UAAU,MAAM,CAAN;MACV,YAAY,QAAQ,MAAM,MAAN,GAAe,CAAvB;MACZ,OAAO,QAAQ,CAAR,EAAW,SAAX,EAAsB,KAAK,SAAL,CAA7B;MACA,QAAQ,KAAK,KAAL;MACR,MAAM,KAAK,GAAL;MACN,SAAS,MAAM,KAAN;MACT,QAAQ,UAAU,GAAV,GAAiB,QAAQ,CAAR;MACzB,YAAY,KAAK,aAAL;MACZ,aAAa,UAAU,MAAV;MACb,WAAW,CAAX;MACA,YAAY,UAAU,MAAV,EAAkB,KAAK,aAAL,CAA9B,CAde;;AAgBnB,MAAI,CAAC,KAAD,IAAU,YAAY,gBAAZ,IAAiC,aAAa,MAAb,IAAuB,aAAa,MAAb,EAAsB;AAC1F,WAAO,iBAAiB,KAAjB,EAAwB,KAAK,WAAL,CAA/B,CAD0F;GAA5F;AAGA,MAAI,SAAS,EAAT,CAnBe;;AAqBnB,SACA,OAAO,YAAY,WAAW,SAAX,EAAsB;AACvC,aAAS,GAAT,CADuC;;AAGvC,QAAI,YAAY,CAAC,CAAD;QACZ,QAAQ,MAAM,KAAN,CAAR,CAJmC;;AAMvC,WAAO,EAAE,SAAF,GAAc,UAAd,EAA0B;AAC/B,UAAI,OAAO,UAAU,SAAV,CAAP;UACA,WAAW,KAAK,QAAL;UACX,OAAO,KAAK,IAAL;UACP,WAAW,SAAS,KAAT,CAAX,CAJ2B;;AAM/B,UAAI,QAAQ,aAAR,EAAuB;AACzB,gBAAQ,QAAR,CADyB;OAA3B,MAEO,IAAI,CAAC,QAAD,EAAW;AACpB,YAAI,QAAQ,gBAAR,EAA0B;AAC5B,mBAAS,KAAT,CAD4B;SAA9B,MAEO;AACL,gBAAM,KAAN,CADK;SAFP;OADK;KART;AAgBA,WAAO,UAAP,IAAqB,KAArB,CAtBuC;GAAzC;AAwBA,SAAO,MAAP,CA9CmB;CAArB;;AAiDA,OAAO,OAAP,GAAiB,SAAjB","file":"lazyValue-compiled.js","sourcesContent":["var baseWrapperValue = require('./baseWrapperValue'),\n    getView = require('./getView'),\n    isArray = require('../lang/isArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to indicate the type of lazy iteratees. */\nvar LAZY_FILTER_FLAG = 1,\n    LAZY_MAP_FLAG = 2;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Extracts the unwrapped value from its lazy wrapper.\n *\n * @private\n * @name value\n * @memberOf LazyWrapper\n * @returns {*} Returns the unwrapped value.\n */\nfunction lazyValue() {\n  var array = this.__wrapped__.value(),\n      dir = this.__dir__,\n      isArr = isArray(array),\n      isRight = dir < 0,\n      arrLength = isArr ? array.length : 0,\n      view = getView(0, arrLength, this.__views__),\n      start = view.start,\n      end = view.end,\n      length = end - start,\n      index = isRight ? end : (start - 1),\n      iteratees = this.__iteratees__,\n      iterLength = iteratees.length,\n      resIndex = 0,\n      takeCount = nativeMin(length, this.__takeCount__);\n\n  if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {\n    return baseWrapperValue(array, this.__actions__);\n  }\n  var result = [];\n\n  outer:\n  while (length-- && resIndex < takeCount) {\n    index += dir;\n\n    var iterIndex = -1,\n        value = array[index];\n\n    while (++iterIndex < iterLength) {\n      var data = iteratees[iterIndex],\n          iteratee = data.iteratee,\n          type = data.type,\n          computed = iteratee(value);\n\n      if (type == LAZY_MAP_FLAG) {\n        value = computed;\n      } else if (!computed) {\n        if (type == LAZY_FILTER_FLAG) {\n          continue outer;\n        } else {\n          break outer;\n        }\n      }\n    }\n    result[resIndex++] = value;\n  }\n  return result;\n}\n\nmodule.exports = lazyValue;\n"]}