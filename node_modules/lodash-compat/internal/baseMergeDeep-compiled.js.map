{"version":3,"sources":["baseMergeDeep.js"],"names":[],"mappings":"AAAA,IAAI,YAAY,QAAQ,aAAR,CAAZ;IACA,cAAc,QAAQ,qBAAR,CAAd;IACA,UAAU,QAAQ,iBAAR,CAAV;IACA,cAAc,QAAQ,eAAR,CAAd;IACA,gBAAgB,QAAQ,uBAAR,CAAhB;IACA,eAAe,QAAQ,sBAAR,CAAf;IACA,gBAAgB,QAAQ,uBAAR,CAAhB;;;;;;;;;;;;;;;;;AAiBJ,SAAS,aAAT,CAAuB,MAAvB,EAA+B,MAA/B,EAAuC,GAAvC,EAA4C,SAA5C,EAAuD,UAAvD,EAAmE,MAAnE,EAA2E,MAA3E,EAAmF;AACjF,MAAI,SAAS,OAAO,MAAP;MACT,WAAW,OAAO,GAAP,CAAX,CAF6E;;AAIjF,SAAO,QAAP,EAAiB;AACf,QAAI,OAAO,MAAP,KAAkB,QAAlB,EAA4B;AAC9B,aAAO,GAAP,IAAc,OAAO,MAAP,CAAd,CAD8B;AAE9B,aAF8B;KAAhC;GADF;AAMA,MAAI,QAAQ,OAAO,GAAP,CAAR;MACA,SAAS,aAAa,WAAW,KAAX,EAAkB,QAAlB,EAA4B,GAA5B,EAAiC,MAAjC,EAAyC,MAAzC,CAAb,GAAgE,SAAhE;MACT,WAAW,WAAW,SAAX,CAZkE;;AAcjF,MAAI,QAAJ,EAAc;AACZ,aAAS,QAAT,CADY;AAEZ,QAAI,YAAY,QAAZ,MAA0B,QAAQ,QAAR,KAAqB,aAAa,QAAb,CAArB,CAA1B,EAAwE;AAC1E,eAAS,QAAQ,KAAR,IACL,KADK,GAEJ,YAAY,KAAZ,IAAqB,UAAU,KAAV,CAArB,GAAwC,EAAxC,CAHqE;KAA5E,MAKK,IAAI,cAAc,QAAd,KAA2B,YAAY,QAAZ,CAA3B,EAAkD;AACzD,eAAS,YAAY,KAAZ,IACL,cAAc,KAAd,CADK,GAEJ,cAAc,KAAd,IAAuB,KAAvB,GAA+B,EAA/B,CAHoD;KAAtD,MAKA;AACH,iBAAW,KAAX,CADG;KALA;GAPP;;;AAdiF,QAgCjF,CAAO,IAAP,CAAY,QAAZ,EAhCiF;AAiCjF,SAAO,IAAP,CAAY,MAAZ,EAjCiF;;AAmCjF,MAAI,QAAJ,EAAc;;AAEZ,WAAO,GAAP,IAAc,UAAU,MAAV,EAAkB,QAAlB,EAA4B,UAA5B,EAAwC,MAAxC,EAAgD,MAAhD,CAAd,CAFY;GAAd,MAGO,IAAI,WAAW,MAAX,GAAqB,WAAW,KAAX,GAAqB,UAAU,KAAV,EAAkB;AACrE,WAAO,GAAP,IAAc,MAAd,CADqE;GAAhE;CAtCT;;AA2CA,OAAO,OAAP,GAAiB,aAAjB","file":"baseMergeDeep-compiled.js","sourcesContent":["var arrayCopy = require('./arrayCopy'),\n    isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isPlainObject = require('../lang/isPlainObject'),\n    isTypedArray = require('../lang/isTypedArray'),\n    toPlainObject = require('../lang/toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates values with source counterparts.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n  var length = stackA.length,\n      srcValue = source[key];\n\n  while (length--) {\n    if (stackA[length] == srcValue) {\n      object[key] = stackB[length];\n      return;\n    }\n  }\n  var value = object[key],\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n      isCommon = result === undefined;\n\n  if (isCommon) {\n    result = srcValue;\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n      result = isArray(value)\n        ? value\n        : (isArrayLike(value) ? arrayCopy(value) : []);\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      result = isArguments(value)\n        ? toPlainObject(value)\n        : (isPlainObject(value) ? value : {});\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  // Add the source value to the stack of traversed objects and associate\n  // it with its merged value.\n  stackA.push(srcValue);\n  stackB.push(result);\n\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n  } else if (result === result ? (result !== value) : (value === value)) {\n    object[key] = result;\n  }\n}\n\nmodule.exports = baseMergeDeep;\n"]}