{"version":3,"sources":["7-mergeRuleset.js"],"names":[],"mappings":"AAAA,IAAI,QAAQ,QAAQ,YAAR,CAAR;AACJ,IAAI,oBAAoB,QAAQ,gBAAR,EAA0B,KAA1B;;;;;;;;;;;;;;AAcxB,SAAS,cAAT,CAAwB,IAAxB,EAA8B,IAA9B,EAAoC,IAApC,EAA0C;AACtC,QAAI,YAAY,KAAK,QAAL,CAAc,SAAd,CADsB;AAEtC,QAAI,eAAe,KAAK,KAAL,CAAW,YAAX,CAFmB;AAGtC,QAAI,oBAAoB,UAAU,KAAV,GAAkB,aAAlB,CAHc;AAItC,QAAI,wBAAwB,EAAxB,CAJkC;;AAMtC,SAAK,SAAL,CAAe,KAAK,IAAL,EAAW,UAAS,IAAT,EAAe,QAAf,EAAyB;;AAE/C,YAAI,KAAK,IAAL,KAAc,SAAd,EAAyB;AACzB,mBAAO,MAAM,gBAAN,CAAuB,IAAvB,CAA4B,SAA5B,EAAuC,IAAvC,CAAP,CADyB;SAA7B;;AAIA,YAAI,KAAK,eAAL,KAAyB,KAAK,eAAL,EAAsB;AAC/C,mBAAO,IAAP,CAD+C;SAAnD;;AAIA,YAAI,oBAAoB,KAAK,QAAL,CAAc,SAAd,CAAwB,IAAxB,CAVuB;AAW/C,YAAI,mBAAmB,KAAK,KAAL,CAAW,YAAX,CAXwB;AAY/C,YAAI,oBAAoB,kBAAkB,IAAlB,CAAuB,aAAvB;;;AAZuB,YAe3C,qBAAqB,qBAArB,EAA4C;AAC5C,mBAAO,IAAP,CAD4C;SAAhD;;;AAf+C,YAoB3C,UAAU,IAAV,KAAmB,UAAU,IAAV,EAAgB;AACnC,gBAAI,UAAU,KAAV,GAAkB,EAAlB,KAAyB,kBAAkB,IAAlB,CAAuB,EAAvB,EAA2B;AACpD,6BAAa,UAAb,CAAwB,gBAAxB,EADoD;AAEpD,qBAAK,MAAL,CAAY,QAAZ,EAFoD;AAGpD,uBAHoD;aAAxD;SADJ;;;AApB+C,YA6B3C,MAAM,mBAAN,CAA0B,YAA1B,EAAwC,gBAAxC,CAAJ,EAA+D;AAC3D,gBAAI,UAAU,kBAAkB,IAAlB,CAAuB,EAAvB,CAD6C;;AAG3D,sBAAU,IAAV,CAAe,UAAS,IAAT,EAAe,IAAf,EAAqB;AAChC,oBAAI,SAAS,KAAK,EAAL,CADmB;;AAGhC,oBAAI,UAAU,MAAV,EAAkB;AAClB,8BAAU,MAAV,CAAiB,iBAAjB,EAAoC,IAApC,EADkB;AAElB,2BAAO,IAAP,CAFkB;iBAAtB;;AAKA,oBAAI,CAAC,KAAK,IAAL,EAAW;AACZ,8BAAU,MAAV,CAAiB,iBAAjB,EADY;AAEZ,2BAAO,IAAP,CAFY;iBAAhB;aARW,CAAf,CAH2D;;AAiB3D,iBAAK,MAAL,CAAY,QAAZ,EAjB2D;AAkB3D,mBAlB2D;SAA/D;;;AA7B+C,YAmD3C,sBAAsB,iBAAtB,EAAyC;AACzC,mBAAO,IAAP,CADyC;SAA7C;;AAIA,8BAAsB,iBAAtB,IAA2C,IAA3C,CAvD+C;KAAzB,CAA1B,CANsC;CAA1C;;AAiEA,OAAO,OAAP,GAAiB,SAAS,YAAT,CAAsB,GAAtB,EAA2B;AACxC,sBAAkB,GAAlB,EAAuB,UAAS,IAAT,EAAe,IAAf,EAAqB,IAArB,EAA2B;AAC9C,YAAI,KAAK,IAAL,KAAc,SAAd,EAAyB;AACzB,2BAAe,IAAf,EAAqB,IAArB,EAA2B,IAA3B,EADyB;SAA7B;KADmB,CAAvB,CADwC;CAA3B","file":"7-mergeRuleset-compiled.js","sourcesContent":["var utils = require('./utils.js');\nvar internalWalkRules = require('../ast/walk.js').rules;\n\n/*\n    At this step all rules has single simple selector. We try to join by equal\n    declaration blocks to first rule, e.g.\n\n    .a { color: red }\n    b { ... }\n    .b { color: red }\n    ->\n    .a, .b { color: red }\n    b { ... }\n*/\n\nfunction processRuleset(node, item, list) {\n    var selectors = node.selector.selectors;\n    var declarations = node.block.declarations;\n    var nodeCompareMarker = selectors.first().compareMarker;\n    var skippedCompareMarkers = {};\n\n    list.nextUntil(item.next, function(next, nextItem) {\n        // skip non-ruleset node if safe\n        if (next.type !== 'Ruleset') {\n            return utils.unsafeToSkipNode.call(selectors, next);\n        }\n\n        if (node.pseudoSignature !== next.pseudoSignature) {\n            return true;\n        }\n\n        var nextFirstSelector = next.selector.selectors.head;\n        var nextDeclarations = next.block.declarations;\n        var nextCompareMarker = nextFirstSelector.data.compareMarker;\n\n        // if next ruleset has same marked as one of skipped then stop joining\n        if (nextCompareMarker in skippedCompareMarkers) {\n            return true;\n        }\n\n        // try to join by selectors\n        if (selectors.head === selectors.tail) {\n            if (selectors.first().id === nextFirstSelector.data.id) {\n                declarations.appendList(nextDeclarations);\n                list.remove(nextItem);\n                return;\n            }\n        }\n\n        // try to join by properties\n        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {\n            var nextStr = nextFirstSelector.data.id;\n\n            selectors.some(function(data, item) {\n                var curStr = data.id;\n\n                if (nextStr < curStr) {\n                    selectors.insert(nextFirstSelector, item);\n                    return true;\n                }\n\n                if (!item.next) {\n                    selectors.insert(nextFirstSelector);\n                    return true;\n                }\n            });\n\n            list.remove(nextItem);\n            return;\n        }\n\n        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)\n        if (nextCompareMarker === nodeCompareMarker) {\n            return true;\n        }\n\n        skippedCompareMarkers[nextCompareMarker] = true;\n    });\n};\n\nmodule.exports = function mergeRuleset(ast) {\n    internalWalkRules(ast, function(node, item, list) {\n        if (node.type === 'Ruleset') {\n            processRuleset(node, item, list);\n        }\n    });\n};\n"]}