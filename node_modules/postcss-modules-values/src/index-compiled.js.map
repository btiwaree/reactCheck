{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["import postcss from 'postcss'\nimport replaceSymbols, { replaceAll } from 'icss-replace-symbols'\n\nconst matchImports = /^(.+?)\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/\nconst matchValueDefinition = /(?:,\\s+|^)([\\w-]+):?\\s+(\"[^\"]*\"|'[^']*'|\\w+\\([^\\)]+\\)|[^,]+)\\s?/g\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/\nlet options = {}\nlet importIndex = 0\nlet createImportedName = options && options.createImportedName || ((importName/*, path*/) => `i__const_${importName.replace(/\\W/g, '_')}_${importIndex++}`)\n\nexport default (css, result) => {\n  let importAliases = []\n  let definitions = {}\n\n  const addDefinition = atRule => {\n    let matches\n    while (matches = matchValueDefinition.exec(atRule.params)) {\n      let [/*match*/, key, value] = matches\n      // Add to the definitions, knowing that values can refer to each other\n      definitions[key] = replaceAll(definitions, value)\n      atRule.remove()\n    }\n  }\n\n  const addImport = atRule => {\n    let matches = matchImports.exec(atRule.params)\n    if (matches) {\n      let [/*match*/, aliases, path] = matches\n      // We can use constants for path names\n      if (definitions[path]) path = definitions[path]\n      let imports = aliases.split(/\\s*,\\s*/).map(alias => {\n        let tokens = matchImport.exec(alias)\n        if (tokens) {\n          let [/*match*/, theirName, myName = theirName] = tokens\n          let importedName = createImportedName(myName)\n          definitions[myName] = importedName\n          return {theirName, importedName}\n        } else {\n          throw new Error(`@import statement \"${alias}\" is invalid!`)\n        }\n      })\n      importAliases.push({path, imports})\n      atRule.remove()\n    }\n  }\n\n  /* Look at all the @value statements and treat them as locals or as imports */\n  css.walkAtRules('value', atRule => {\n    if (matchImports.exec(atRule.params)) {\n      addImport(atRule)\n    } else {\n      if (atRule.params.indexOf('@value') !== -1) {\n        result.warn('Invalid value definition: ' + atRule.params)\n      }\n\n      addDefinition(atRule)\n    }\n  })\n\n  /* We want to export anything defined by now, but don't add it to the CSS yet or\n  it well get picked up by the replacement stuff */\n  let exportDeclarations = Object.keys(definitions).map(key => postcss.decl({\n    value: definitions[key],\n    prop: key,\n    raws: { before: \"\\n  \" },\n    _autoprefixerDisabled: true\n  }))\n\n  /* If we have no definitions, don't continue */\n  if (!Object.keys(definitions).length) return\n\n  /* Perform replacements */\n  replaceSymbols(css, definitions)\n\n  /* Add export rules if any */\n  if (exportDeclarations.length > 0) {\n    css.prepend(postcss.rule({\n      selector: `:export`,\n      raws: { after: \"\\n\" },\n      nodes: exportDeclarations\n    }))\n  }\n\n  /* Add import rules */\n  importAliases.reverse().forEach(({path, imports}) => {\n    css.prepend(postcss.rule({\n      selector: `:import(${path})`,\n      raws: { after: \"\\n\" },\n      nodes: imports.map(({theirName, importedName}) => postcss.decl({\n        value: theirName,\n        prop: importedName,\n        raws: { before: \"\\n  \" },\n        _autoprefixerDisabled: true\n      }))\n    }))\n  })\n}\n"]}