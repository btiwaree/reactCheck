{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert')\nvar signals = require('./signals.js')\n\nvar EE = require('events')\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter\n}\n\nvar emitter\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE()\n  emitter.count = 0\n  emitter.emitted = {}\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n  if (loaded === false) {\n    load()\n  }\n\n  var ev = 'exit'\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit'\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb)\n    if (emitter.listeners('exit').length === 0 &&\n        emitter.listeners('afterexit').length === 0) {\n      unload()\n    }\n  }\n  emitter.on(ev, cb)\n\n  return remove\n}\n\nmodule.exports.unload = unload\nfunction unload () {\n  if (!loaded) {\n    return\n  }\n  loaded = false\n\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig])\n    } catch (er) {}\n  })\n  process.emit = originalProcessEmit\n  process.reallyExit = originalProcessReallyExit\n  emitter.count -= 1\n}\n\nfunction emit (event, code, signal) {\n  if (emitter.emitted[event]) {\n    return\n  }\n  emitter.emitted[event] = true\n  emitter.emit(event, code, signal)\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {}\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener () {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig)\n    if (listeners.length === emitter.count) {\n      unload()\n      emit('exit', null, sig)\n      /* istanbul ignore next */\n      emit('afterexit', null, sig)\n      /* istanbul ignore next */\n      process.kill(process.pid, sig)\n    }\n  }\n})\n\nmodule.exports.signals = function () {\n  return signals\n}\n\nmodule.exports.load = load\n\nvar loaded = false\n\nfunction load () {\n  if (loaded) {\n    return\n  }\n  loaded = true\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1\n\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig])\n      return true\n    } catch (er) {\n      return false\n    }\n  })\n\n  process.emit = processEmit\n  process.reallyExit = processReallyExit\n}\n\nvar originalProcessReallyExit = process.reallyExit\nfunction processReallyExit (code) {\n  process.exitCode = code || 0\n  emit('exit', process.exitCode, null)\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null)\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode)\n}\n\nvar originalProcessEmit = process.emit\nfunction processEmit (ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg\n    }\n    var ret = originalProcessEmit.apply(this, arguments)\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    return ret\n  } else {\n    return originalProcessEmit.apply(this, arguments)\n  }\n}\n"]}