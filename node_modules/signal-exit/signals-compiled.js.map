{"version":3,"sources":["signals.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAgBA,OAAO,OAAP,GAAiB,CACf,SADe,EAEf,SAFe,EAGf,QAHe,EAIf,QAJe,EAKf,QALe,EAMf,QANe,EAOf,QAPe,EAQf,QARe,EASf,SATe,EAUf,SAVe,EAWf,SAXe,EAYf,SAZe,EAaf,QAbe,EAcf,SAde,EAef,SAfe,EAgBf,SAhBe,EAiBf,WAjBe,EAkBf,SAlBe,EAmBf,SAnBe,CAAjB;;AAsBA,IAAI,QAAQ,QAAR,KAAqB,OAArB,EAA8B;AAChC,SAAO,OAAP,CAAe,IAAf,CACE,OADF,EAEE,SAFF,EAGE,QAHF,EAIE,WAJF,EAKE,WALF,EADgC;CAAlC","file":"signals-compiled.js","sourcesContent":["// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGBUS',\n  'SIGFPE',\n  'SIGHUP',\n  'SIGILL',\n  'SIGINT',\n  'SIGIOT',\n  'SIGPIPE',\n  'SIGPROF',\n  'SIGQUIT',\n  'SIGSEGV',\n  'SIGSYS',\n  'SIGTERM',\n  'SIGTRAP',\n  'SIGUSR2',\n  'SIGVTALRM',\n  'SIGXCPU',\n  'SIGXFSZ'\n]\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n"]}