{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["'use strict'\nvar url = require('url')\nvar gitHosts = require('./git-host-info.js')\nvar GitHost = module.exports = require('./git-host.js')\n\nvar protocolToRepresentationMap = {\n  'git+ssh': 'sshurl',\n  'git+https': 'https',\n  'ssh': 'sshurl',\n  'git': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  if (protocol.substr(-1) === ':') protocol = protocol.slice(0, -1)\n  return protocolToRepresentationMap[protocol] || protocol\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nmodule.exports.fromUrl = function (giturl) {\n  if (giturl == null || giturl === '') return\n  var url = fixupUnqualifiedGist(\n    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl\n  )\n  var parsed = parseGitUrl(url)\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    var gitHostInfo = gitHosts[gitHostName]\n    var auth = null\n    if (parsed.auth && authProtocols[parsed.protocol]) {\n      auth = decodeURIComponent(parsed.auth)\n    }\n    var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null\n    var user = null\n    var project = null\n    var defaultRepresentation = null\n    if (parsed.protocol === gitHostName + ':') {\n      user = decodeURIComponent(parsed.host)\n      project = parsed.path && decodeURIComponent(parsed.path.replace(/^[/](.*?)(?:[.]git)?$/, '$1'))\n      defaultRepresentation = 'shortcut'\n    } else {\n      if (parsed.host !== gitHostInfo.domain) return\n      if (!gitHostInfo.protocols_re.test(parsed.protocol)) return\n      var pathmatch = gitHostInfo.pathmatch\n      var matched = parsed.path.match(pathmatch)\n      if (!matched) return\n      if (matched[1] != null) user = decodeURIComponent(matched[1])\n      if (matched[2] != null) project = decodeURIComponent(matched[2])\n      defaultRepresentation = protocolToRepresentation(parsed.protocol)\n    }\n    return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation)\n  }).filter(function (gitHostInfo) { return gitHostInfo })\n  if (matches.length !== 1) return\n  return matches[0]\n}\n\nfunction isGitHubShorthand (arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg)\n}\n\nfunction fixupUnqualifiedGist (giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl)\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host\n  } else {\n    return giturl\n  }\n}\n\nfunction parseGitUrl (giturl) {\n  if (typeof giturl !== 'string') giturl = '' + giturl\n  var matched = giturl.match(/^([^@]+)@([^:]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)\n  if (!matched) return url.parse(giturl)\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] +\n          '/' + matched[3] + (matched[4] || '')\n  }\n}\n"]}