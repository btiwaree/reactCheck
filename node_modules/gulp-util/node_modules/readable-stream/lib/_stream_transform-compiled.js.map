{"version":3,"sources":["_stream_transform.js"],"names":[],"mappings":"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","file":"_stream_transform-compiled.js","sourcesContent":["// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er) {\n      done(stream, er);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er) {\n  if (er) return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}"]}